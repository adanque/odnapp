# Docs for the Azure Web Apps Deploy action: https://github.com/Azure/webapps-deploy
# More GitHub Actions for Azure: https://github.com/Azure/actions
# More info on Python, GitHub Actions, and Azure App Service: https://aka.ms/python-webapps-actions

name: Build and deploy Python app to Azure Web App - odnapp

on:
  push:
    branches:
      - main
  workflow_dispatch:

jobs:
  build:
    runs-on: ubuntu-latest
    permissions:
      contents: read #This is required for actions/checkout

    steps:
      - uses: actions/checkout@v4

      - name: Set up Python version
        uses: actions/setup-python@v5
        with:
          python-version: '3.13'

      # 🛠️ Local Build Section (Optional)
      # The following section in your workflow is designed to catch build issues early on the client side, before deployment. This can be helpful for debugging and validation. However, if this step significantly increases deployment time and early detection is not critical for your workflow, you may remove this section to streamline the deployment process.
      - name: Create and Start virtual environment and Install dependencies
        run: |
          python -m venv venv
          source venv/bin/activate
        
          #python -m venv antenv
          #source antenv/bin/activate
          #pip install -r requirements.txt

      - name: Install dependencies
        run: pip install -r requirements.txt          

      - name: Test Redis Connection - Install redis-py
        run: |
          pip install redis

      - name: Use a secret in a command
        run: echo "The REDIS_PORT is ${{ secrets.REDIS_PORT }}"
        
      - name: Pass a REDIS_PORT secret as an environment variable
        run: echo "MY_ENV_REDIS_PORT_SECRET=${{ secrets.REDIS_PORT }}"
       
#        run: echo "MY_ENV_REDIS_PORT_SECRET=${{ secrets.REDIS_PORT }}" >> $REDIS_PORT_ENV        
#        env:
#          MY_VARIABLE: ${{ secrets.REDIS_PORT }}
#        run: |
#          echo "Using the REDIS_PORT secret from an environment variable"
#          echo $MY_VARIABLE        

      - name: Conditional Test Redis Port
        if: ${{ env.MY_ENV_REDIS_PORT_SECRET == '6379' }}
        run: |
            echo "The secret MY_ENV_REDIS_PORT_SECRET matches '6379'."

      - name: Conditional Test Redis Port not correct
        if: ${{ env.MY_ENV_REDIS_PORT_SECRET != '6379' }}
        run: |
            echo "The secret MY_ENV_REDIS_PORT_SECRET does not match '6379'."

      - name: Debug secret
        run: |
            if [ -z "${{ secrets.REDIS_PORT }}" ]; then
              echo "REDIS_PORT is missing or empty"
            else
              echo "REDIS_PORT is set (length: ${#REDIS_PORT})"
            fi

#          if [ "${{ secrets.REDIS_PORT }}" == "6379" ]; then
#            echo "secrets.REDIS_PORT is correct"
#          fi
#      - name: Test Redis-Stack TCP port access with nc
#        run: |
#          if [ -z "${{ secrets.REDIS_PORT }}" ]; 
#          then echo "REDIS_PORT Secret is missing";
#          if [ -z "${{ secrets.REDIS_HOST }}" ]; then echo "REDIS_HOST Secret is missing";
#        env:
#          REDIS_HOST: ${{ secrets.REDIS_HOST }}
#          REDIS_PORT: ${{ secrets.REDIS_PORT }}

#          nc -zv ${{ secrets.REDIS_HOST }} ${{ secrets.REDIS_PORT }}      

      - name: Test Redis-Stack TCP port access with nc
        run: |
          nc -zv 10.0.2.4 6379

      - name: Test Redis-Stack TCP port access with Python
        run: |
          python -c "import socket; s = socket.socket(socket.AF_INET, socket.SOCK_STREAM); s.settimeout(5); try: s.connect(('10.0.2.4', int('6379'))); print('Connection successful'); s.close(); exit(0); except socket.error as e: print(f'Connection failed: {e}'); exit(1);"
#        env:
#          REDIS_HOST: ${{ secrets.REDIS_HOST }}
#          REDIS_PORT: ${{ secrets.REDIS_PORT }}

                
      # By default, when you enable GitHub CI/CD integration through the Azure portal, the platform automatically sets the SCM_DO_BUILD_DURING_DEPLOYMENT application setting to true. This triggers the use of Oryx, a build engine that handles application compilation and dependency installation (e.g., pip install) directly on the platform during deployment. Hence, we exclude the antenv virtual environment directory from the deployment artifact to reduce the payload size. 
      - name: Upload artifact for deployment jobs
        uses: actions/upload-artifact@v4
        with:
          name: python-app
          path: |
            .
            !antenv/

      # 🚫 Opting Out of Oryx Build
      # If you prefer to disable the Oryx build process during deployment, follow these steps:
      # 1. Remove the SCM_DO_BUILD_DURING_DEPLOYMENT app setting from your Azure App Service Environment variables.
      # 2. Refer to sample workflows for alternative deployment strategies: https://github.com/Azure/actions-workflow-samples/tree/master/AppService
      

  deploy:
    runs-on: ubuntu-latest
    needs: build
    permissions:
      id-token: write #This is required for requesting the JWT
      contents: read #This is required for actions/checkout

    steps:
      - name: Download artifact from build job
        uses: actions/download-artifact@v4
        with:
          name: python-app
      
      - name: Login to Azure
        uses: azure/login@v2
        with:
          client-id: ${{ secrets.AZUREAPPSERVICE_CLIENTID_289AB8C2E7D5435B84682D46B90C91E1 }}
          tenant-id: ${{ secrets.AZUREAPPSERVICE_TENANTID_68096D5C7083439786200120344975BB }}
          subscription-id: ${{ secrets.AZUREAPPSERVICE_SUBSCRIPTIONID_89BB9141E00C402492E534A757FDA661 }}

      - name: 'Deploy to Azure Web App'
        uses: azure/webapps-deploy@v3
        id: deploy-to-webapp
        with:
          app-name: 'odnapp'
          slot-name: 'Production'
        env:
          MY_APP_SETTING: ${{ secrets.MY_GITHUB_SECRET }}          
